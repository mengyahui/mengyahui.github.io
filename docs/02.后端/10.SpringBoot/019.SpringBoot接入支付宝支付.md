支付功能如今已经成为一个需要盈利的网站的基本功能了，通常都是选择接入第三方平台如支付宝、微信等。本文主要介绍了 SpringBoot 项目如何接入支付宝支付、转账以及退款等功能。

## 一、开发环境准备

开发接入支付宝在线支付功能，需要先在支付宝创建应用，并为这些应用添加相应的支付能力。但这些能力，是需要在支付宝商家中心进行签约的，一般都要求提交营业执照等信息，接入门槛比较高，对于开发者来说，可以使用支付宝提供可沙箱环境进行接入，后期也可以很方便的切换到正式环境。

### 1.1 沙箱环境

**① 进入沙箱环境**

登录[支付宝开放平台](https://open.alipay.com/)的控制台，在开发工具推荐选项下点击沙箱，即可进入沙箱环境。*默认的沙箱环境已经初始化了一个网页/移动应用和小程序*。

![image-20230518100541400](https://cdn.jsdelivr.net/gh/mengyahui/image-repository@master/springboot/image-20230518100541400.74wg0v47a1s0.jpg)

这里我们只关注*网页/移动应用*，上图中的 APPID 作为应用的唯一标识，是接入在线支付功能需要用到的。

**② 获取公钥/证书**

支付接口涉及到资金的流转，必须要保证其安全性。支付宝通过对数据传输的接口进行加签来保证资金流转的安全性。

![image-20230518102034979](https://cdn.jsdelivr.net/gh/mengyahui/image-repository@master/springboot/image-20230518102034979.czthins6qlc.jpg)

沙箱应用提供了系统默认密钥供开发者使用，分为公钥加签和证书加签两种模式。其中涉及到资金支出的接口必须使用证书加签模式。

公钥模式：需要获取*应用私钥（Java语言）*和*支付宝公钥*两项。

在证书模式：需要获取 *应用公钥证书*、*应用私钥（Java语言）*、*支付宝公钥证书*和*支付宝根证书*四项。

**③ 获取沙箱账号**

沙箱环境提供了默认的沙箱账号，分为买家账号和商家账号，若要使用买家账号向商家账号付款，则需要支付宝沙箱版本的客户端，仅提供了Android版本，下载地址：https://open.alipay.com/develop/sandbox/tool/alipayclint

![image-20230518105046663](https://cdn.jsdelivr.net/gh/mengyahui/image-repository@master/springboot/image-20230518105046663.wzvwovbk2f4.jpg)

### 1.2 正式环境

正式环境接入支付宝在线支付功能不同于沙箱环境，下图是手机网站支付的接入流程

![img](https://yuque.antfin.com/images/lark/0/2022/jpeg/210044/1669294732057-74af7e26-aabc-4f9b-abbf-a440d2c23e30.jpeg?x-oss-process=image%2Fresize%2Cw_1554)


具体的接入流程可参考官方文档 https://opendocs.alipay.com/open/200/105310?pathHash=7f6d049a

## 二、项目准备

### 2.1 导入坐标

在 SpringBoot 项目中导入支付宝提供的 sdk。

```xml
<dependency>
    <groupId>com.alipay.sdk</groupId>
    <artifactId>alipay-sdk-java</artifactId>
    <version>4.35.132.ALL</version>
</dependency>
```

### 2.2 配置证书/密钥

在 `application.yml` 配置文件中，配置如下信息：

```yaml
alipay:
  app-id: 2021000122678961 # APPID
  app-private-key: MI********* # 应用私钥
  app-cert-path: /cert/appPublicCert.crt # 应用公钥证书路径
  alipay-cert-path: /cert/alipayPublicCert.crt # 支付宝公钥证书路径
  root-cert-path: /cert/alipayRootCert.crt # 支付宝根证书路径
```

其中证书加签模式的三个证书放在了项目`resources/cert` 目录下。除此之外的其它配置信息作为常量放到了 Java 类中。

```java
public class AlipayConstant {

    // 支付宝网关地址沙箱环境下固定为：https://openapi.alipaydev.com/gateway.do
    // 正式环境固定为：https://openapi.alipay.com/gateway.do
    public static final String gateway = "https://openapi.alipaydev.com/gateway.do";

    // 接口加签方式
    public static final String signType = "RSA2";

    // 字符编码格式
    public static final String charset = "utf-8";

    // 数据传输格式
    public static final String format = "json";

    // 页面跳转的同步通知路径，需http://格式的完整路径，且不能是内网路径，不能加?id=123这类自定义参数
    public static final String returnUrl = "http://localhost:8080/alipay/success";
    
    // 支付宝服务器的异步通知路径，需http://格式的完整路径，且不能是内网路径
    public static final String notifyUrl = "http://localhost:8080/alipay/success";
}
```

其中，同步通知地址可设置为后端支付成功的页面地址或前端支付成功的页面地址，异步通知地址必须由后端处理。在开发环境下可使用内网穿透工具来让我们本地的服务可以被支付宝服务访问到，进而触发异步通知。

关于内网穿透工具，这里推荐 natapp，百度一下很快就能 get 到。

### 2.3 创建支付客户端

发送支付宝提供的各种支付接口都需要使用支付宝 SDK 提供的支付客户端，下面给出了证书模式的支付客户端的配置。

```java
@Configuration
public class AlipayConfig {

    @Value("${alipay.app-id}")
    private String appId;

    @Value("${alipay.app-private-key}")
    private String privateKey;

    @Value("${alipay.app-cert-path}")
    private String appCertPath;

    @Value("${alipay.alipay-cert-path}")
    private String alipayCertPath;

    @Value("${alipay.root-cert-path}")
    private String rootCertPath;


    @Bean
    public AlipayClient getAlipayClient() throws AlipayApiException {

        CertAlipayRequest config = new CertAlipayRequest();
        config.setServerUrl(AlipayConstant.gateway);
        config.setSignType(AlipayConstant.signType);
        config.setCharset(AlipayConstant.charset);
        config.setFormat(AlipayConstant.format);
        config.setAppId(appId);
        config.setPrivateKey(privateKey);
        config.setCertPath(getRealPath(appCertPath));
        config.setAlipayPublicCertPath(getRealPath(alipayCertPath));
        config.setRootCertPath(getRealPath(rootCertPath));

        return new DefaultAlipayClient(config);
    }

    private String getRealPath(String path){
        String absolutePath = null;
        try {
            absolutePath = new ClassPathResource(path).getFile().getAbsolutePath();
        } catch (IOException e) {
            throw new RuntimeException("证书不存在");
        }
        return absolutePath;
    }
}
```

### 2.4 创建业务接口

这里不仅给出了支付业务的业务接口，还给出了转账以及退款的业务接口。此外这些接口所用到的参数在具体接入的时候会详细说明。

业务接口返回的 Result 封装的统一响应处理类，代码如下：

```java
@Data
@JsonInclude(JsonInclude.Include.NON_NULL)
@AllArgsConstructor
public class Result {

    private Integer code;

    private String message;

    private Object data;

    public static Result fail(String message) {
        return new Result(500, message,null);
    }

    public static Result success(String message,Object data) {
        return new Result(200, message, data);
    }

}
```

#### 2.4.1 支付业务接口

```java
public interface AlipayService {

    /**
     * 电脑网站支付
     * @param payParam 支付参数
     */
    String computePay(PayParam payParam);

    /**
     * 手机网站支付
     * @param payParam 支付参数
     */
    String mobilePay(PayParam payParam);

    /**
     * 当面付（用户扫描商户二维码支付）
     * @param payParam 支付参数
     */
    String faceToFacePay(PayParam payParam);

    /**
     * 查询支付结果
     * @param payQueryParam 支付结果查询参数
     */
    Result queryPay(PayQueryParam payQueryParam);

    /**
     * 查询对账单下载地址
     * @param billQueryParam 对账单下载地址查询参数
     */
    Result queryBill(BillQueryParam billQueryParam);

}
```

#### 2.4.2 通知业务接口

```java
public interface AliNotifyService {

    /**
     * 请求的异步回调
     */
    void notifyCallback(HttpServletRequest request, HttpServletResponse response);

    /**
     * 请求的同步回调
     */
    void returnCallback(HttpServletRequest request, HttpServletResponse response);

}
```

#### 2.4.3 退款业务接口

```java
public interface AliRefundService {

    /**
     * 退款
     * @param refundParam 退款参数
     */
    Result refund(@RequestBody RefundParam refundParam);

    /**
     * 查询退款结果
     * @param refundQueryParam 退款结果查询参数
     */
    Result queryRefund(@RequestBody RefundQueryParam refundQueryParam);
}
```

#### 2.4.4 转账业务接口

```java
@Service
public interface AliTransferService {

    /**
     * 查询商户账户余额
     */
    Map<String,String> queryAccount();

    /**
     * 查询转账结果
     * @param queryParam 转账结果查询参数
     */
    Result queryTransfer(@RequestBody TransferQueryParam queryParam);

    /**
     * 单笔无密转账
     * @param transferParam 转账参数
     */
    Result transfer(@RequestBody TransferParam transferParam);
}
```

### 2.5 创建请求接口

下面给出了支付、通知、退款和转账等功能的请求接口。

#### 2.5.1 支付请求接口

```java
@RestController
@RequestMapping("alipay")
public class AlipayController {

    @Resource
    private AlipayService alipayService;

    @PostMapping("computer")
    public Result computerPay(@RequestBody PayParam payParam) {
        String form = alipayService.computePay(payParam);
        return Result.success("操作成功",form);
    }

    @PostMapping("mobile")
    public Result mobilePay(@RequestBody PayParam payParam) {
        String form = alipayService.mobilePay(payParam);
        return Result.success("操作成功",form);
    }
    @PostMapping("faceToFace")
    public Result faceToFacePay(@RequestBody PayParam payParam) {
        String qrcode = alipayService.faceToFacePay(payParam);
        return Result.success("操作成功",qrcode);
    }

    @PostMapping("payQuery")
    public Result payQuery(@RequestBody PayQueryParam payQuery) {
        return alipayService.queryPay(payQuery);
    }
    
    @PostMapping("billQuery")
    public Result billQuery(@RequestBody BillQueryParam queryParam) {
        String downloadUrl = alipayService.queryBill(queryParam);
        return downloadUrl != null
                ? Result.success("操作成功", null)
                : Result.fail("操作失败");
    }

}
```

#### 2.5.2 通知请求接口

```java
@RestController
@RequestMapping("aliNotify")
public class AliNotifyController {

    @Resource
    private AliNotifyService aliNotifyService;
    @PostMapping("notify")
    public void notifyCheck(HttpServletRequest request) {
        aliNotifyService.notifyCallback(request);
    }

    @GetMapping("return")
    public Result returnCheck(HttpServletRequest request) {
        boolean isChecked = aliNotifyService.returnCallback(request);
        return isChecked ? Result.success("支付成功",null) : Result.fail("支付失败");
    }

}
```

#### 2.5.3 退款请求接口

```java
@RestController
@RequestMapping("aliRefund")
public class AliRefundController {
    @Resource
    private AliRefundService aliRefundService;
    @PostMapping("refund")
    public Result refund(@RequestBody RefundParam refundParam) {
        return  aliRefundService.refund(refundParam);
    }

    @PostMapping("queryRefund")
    public Result queryRefund(@RequestBody RefundQueryParam queryParam) {
        return aliRefundService.queryRefund(queryParam);
    }

}
```

#### 2.5.4 转账请求接口

```java
@RestController
@RequestMapping("aliTransfer")
public class AliTransferController {

    @Resource
    private AliTransferService aliTransferService;

    @PostMapping("transfer")
    public Result transfer(@RequestBody TransferParam transferParam) {
        return aliTransferService.transfer(transferParam);
    }

    @PostMapping("queryTransfer")
    public Result queryTransfer(@RequestBody TransferQueryParam queryParam) {
        return aliTransferService.queryTransfer(queryParam);
    }

    @PostMapping("queryAccount")
    public Result queryAccount() {
        Map<String, String> result = aliTransferService.queryAccount();
        return Result.success("查询成功", result);
    }
}
```



## 三、支付接入

支付接入的流程都是类似的，下图是电脑网站支付的支付流程，在接入其它支付功能时会介绍其不同之处。

![image-20230522082056884](https://cdn.jsdelivr.net/gh/mengyahui/image-repository@master/springboot/image-20230522082056884.1dqo7xwys8g.jpg)

### 3.1 电脑网站支付

电脑网站支付会返回一个支付表单，需要在前端模拟表单提交来唤起支付窗口。用户**扫描支付二维码**或**填写账号密码**即可完成支付。

#### 3.1.1 请求参数

| 参数         | 是否必选 | 描述                                                         |
| ------------ | -------- | ------------------------------------------------------------ |
| out_trade_no | 必选     | 商户订单号                                                   |
| total_amount | 必选     | 订单总金额，单位为元，精确到小数点后两位，取值范围为 [0.01,100000000]。 |
| subject      | 必选     | 订单标题。注意：不可使用特殊字符，如 /，=，& 等              |
| product_code | 必选     | 销售产品码。目前电脑支付场景下仅支持 FAST_INSTANT_TRADE_PAY  |
| qr_pay_mode  | 可选     | PC 扫码支付的方式。                                          |
| qrcode_width | 可选     | 商户自定义二维码宽度。注：qr_pay_mode = 4 时该参数有效       |

`qr_pay_mode`：PC 扫码支付支持前置模式和跳转模式，不传该参数默认是跳转模式。

**前置模式**：将二维码前置到商户的订单确认页，需要商户在自己的页面中以 iframe 方式请求支付宝页面。

**跳转模式**：用户的扫码界面是由支付宝生成的，不在商户的域名下。

PC 端具体支持的扫码支付模式如下：

1. `qr_pay_mode = 0`：订单码-简约前置模式，对应 iframe 宽度不能小于 600px，高度不能小于 300px；
2. `qr_pay_mode = 1`：订单码-前置模式，对应 iframe 宽度不能小于 300px，高度不能小于 600px；
3. `qr_pay_mode = 3`：订单码-迷你前置模式，对应 iframe 宽度不能小于 75px，高度不能小于75px；
4. `qr_pay_mode = 4`：订单码-可定义宽度的嵌入式二维码，商户可根据需要设定二维码的大小。
5. `qr_pay_mode = 2`：订单码-跳转模式。

这里以跳转模式为例，构造的支付参数为：

```java
@Data
public class PayParam {

    private String outTradeNo;

    private String subject;

    private String totalAmount;

    private String qrPayMode;

    private String qrcodeWidth;

}
```

#### 3.1.2 支付逻辑

> 支付请求：`com.alipay.api.request.AlipayTradePagePayRequest`
>
> 业务参数：`com.alipay.api.domain.AlipayTradePagePayModel`

电脑网站支付的逻辑如下：

```java
@Service
public class AlipayServiceImpl implements AlipayService {

    @Resource
    private AlipayClient alipayClient;
    
    @Override
    public String computePay(PcPayParam payParam) {
        // 创建电脑网站支付请求
        AlipayTradePagePayRequest request = new AlipayTradePagePayRequest();
        // 设置异步回调地址
        request.setNotifyUrl(AlipayConstant.notifyUrl);
        // 设置同步回调地址
        request.setReturnUrl(AlipayConstant.returnUrl);
        // 创建业务参数对象
        AlipayTradePagePayModel model = new AlipayTradePagePayModel();
        model.setOutTradeNo(payParam.getOutTradeNo());
        model.setSubject(payParam.getSubject());
        model.setTotalAmount(payParam.getTotalAmount());
        if (StringUtils.hasLength(payParam.getQrPayMode())) {
            model.setQrPayMode(payParam.getQrPayMode());
            if (Objects.equals(payParam.getQrPayMode(), "4")) {
                model.setQrcodeWidth(model.getQrcodeWidth());
            }
        }
        model.setProductCode(AlipayConstant.computePayProductCode);
        // 设置业务参数
        request.setBizModel(model);
        AlipayTradePagePayResponse response = null;
        try {
            // 客户端发送请求
            response = alipayClient.pageExecute(request);
        } catch (AlipayApiException e) {
            e.printStackTrace();
            throw new RuntimeException("支付宝返回支付表单失败");
        }
        boolean isSuccess = response.isSuccess();
        return isSuccess ? response.getBody() : null;
    }
}
```

#### 3.1.3 支付接口

电脑网站支付的接口如下：

```java
@RestController
@RequestMapping("alipay")
public class AlipayController {

    @Resource
    private AlipayService alipayService;

    @PostMapping("pc")
    public Result computerPay(@RequestBody PcPayParam payParam) {
        String form = alipayService.computePay(payParam);
        return form != null
                ? Result.success("操作成功",form)
                : Result.fail("返回支付表单失败");
    }
}
```

#### 3.1.4 渲染表单

电脑网站支付的接口返回的 form 字符串需要在商家客户端模拟 js 提交表单来获取支付页面。如果前端使用的是 vue 可以像下面这样来渲染 form。

```java
<script>
new Vue({
    el: '#app',
    data: {
        form: {
            outTradeNo: '1213456',
            subject: '测试支付',
            totalAmount: '1'
        }
    },
    methods: {
        submit() {
            fetch('alipay/computer',{
                method: 'POST',
                body: JSON.stringify(this.form),
                headers: {
                    'Content-Type': 'application/json'
                }
            }).then(response => response.json())
                .then(response => {
                    const { data } = response
                    const div = document.createElement('payForm')
                    div.innerHTML = data
                    document.body.appendChild(div)
                    const len = document.forms.length - 1
                    document.forms[len].setAttribute('target', '_blank')
                    document.forms[len].submit()
                })
        }
    }
})
</script>
```

#### 3.1.5 接口回调

在向支付宝发送请求时，我们配置了支付宝的同步回调地址和异步回调地址，当支付宝服务器接收到这个支付请求时会通过同步回调接口返回一个结果，但是这个结果，只是告诉你调用成功了，并不是扣款成功。当支付宝服务器完成扣款接口的调用时，才会通过异步回调接口通知商家客户端支付是否成功。

通常，在同步接口中处理订单逻辑，将“待支付”状态更新为 “已支付”状态，在根据异步接口的处理结果进一步确认该笔订单是否支付成功。

**接口验签：**

无论是同步回调还是异步回调，都需要进行接口验签，且验签代码比较固定。下面接入的支付功能不再提及。下面的代码是验签的逻辑，只需要在同步回调和异步回调接口中调用即可。

```java
@Service
@Slf4j
public class AliNotifyServiceImpl implements AliNotifyService {
    
    @Value("${alipay.alipay-cert-path}")
    private String alipayCertPath;
    
    private boolean check(HttpServletRequest request) {
        // 获取订单号
        String out_trade_no = request.getParameter("out_trade_no");
        // 获取支付宝交易号
        String trade_no = request.getParameter("trade_no");
        // 获取验签 Map
        Map<String, String> paramMap = convertRequestParamsToMap(request);
        try {
            return AlipaySignature.rsaCertCheckV1(
                paramMap, 
                alipayCertPath, 
                AlipayConstant.charset, 
                AlipayConstant.signType
            );
        } catch (AlipayApiException e) {
            log.error("支付宝验签失败,订单号{},支付宝交易号{}",out_trade_no,trade_no);
            e.printStackTrace();
        }
        return false;
    }

    private Map<String,String> convertRequestParamsToMap(HttpServletRequest request) {
        Map<String, String> retMap = new HashMap<>();
        Map<String, String[]> requestParams = request.getParameterMap();
        for (String name : requestParams.keySet()) {
            String[] values = requestParams.get(name);
            String valueStr = "";
            for (int i = 0; i < values.length; i++) {
                valueStr = (i == values.length - 1) 
                    ? valueStr + values[i] 
                    : valueStr + values[i] + ",";
            }
            retMap.put(name, valueStr);
        }
        return retMap;
    }
}
```

**同步回调：**

在同步回调逻辑：

```java
@Service
@Slf4j
public class AliNotifyServiceImpl implements AliNotifyService {
    ......
    @Override
    public boolean returnCallback(HttpServletRequest request) {
        // 获取订单号
        String out_trade_no = request.getParameter("out_trade_no");
        // 获取支付宝交易号
        String trade_no = request.getParameter("trade_no");
        // 接口验签
        boolean isChecked = check(request);
        if (isChecked) {
            log.info("支付宝同步验签成功,订单号：{},支付宝交易号：{}", out_trade_no, trade_no);
            // 处理订单逻辑
        } else {
            log.error("支付宝同步验签失败,订单号：{},支付宝交易号：{}", out_trade_no, trade_no);
        }
        return isChecked;
    }
    ......
}
```

对于同步回调的接口来说，商户服务端可选择服务端渲染支付成功页，也可以选择直接跳转至商户客户端指定的成功页面。这里选择跳转至商户客户端指定的成功页面。

```java
@Controller
@RequestMapping("aliNotify")
public class AliNotifyController {

    @Resource
    private AliNotifyService aliNotifyService;
    
    @GetMapping("return")
    public void returnCheck(HttpServletRequest request, HttpServletResponse response){
        boolean isChecked = aliNotifyService.returnCallback(request);
        try {
            if (isChecked) {
                response.sendRedirect("http://localhost:5173/#/success");
            } else {
                response.sendRedirect("http://localhost:5173/#/error");
            }
        } catch (IOException e) {
            throw new RuntimeException("同步跳转失败");
        }
    }
}
```

**异步回调：**

异步回调逻辑：

```java
@Service
@Slf4j
public class AliNotifyServiceImpl implements AliNotifyService {
    ......
    @Override
    public void notifyCallback(HttpServletRequest request, HttpServletResponse response) {
        // 获取交易状态
        String trade_status = request.getParameter("trade_status");
        // 获取订单号
        String out_trade_no = request.getParameter("out_trade_no");
        // 获取支付宝交易号
        String trade_no = request.getParameter("trade_no");
        // 接口验签
        boolean isChecked = check(request);
        if (isChecked) {
            log.info("支付宝异步回调验签成功,订单号{},支付宝交易号{}", out_trade_no, trade_no);
            // 判断交易是否成功
            if(tradeStatus.equals("TRADE_SUCCESS")||tradeStatus.equals("TRADE_FINISHED")) {
                // 查询数据库中订单是否支付成功，支付成功则无需做操作，否则需要更新订单状态
                log.info("订单{}支付成功,支付宝交易号:{}", out_trade_no, trade_no);
                // 交易成功后需要向支付宝返回success字符串，
                // 否则支付宝后台会在一定的时间间隔内重复发起异步回调返回支付结果
                try {
                    response.getWriter().println("success");
                } catch (IOException e) {
                    log.error("IO异常,订单号{},支付宝交易号{}",out_trade_no, trade_no);
                }
            }
        } else {
            log.error("支付宝异步验签失败,订单号{},支付宝交易号{}", out_trade_no, trade_no);
        }
    }
    ......
}
```

### 3.2 手机网站支付

和电脑网站支付类似，手机网站支付同样会返回一个支付表单，需要前端模拟表单提交来唤起支付窗口。不同的是，手机网站的支付窗口可以选择调出支付宝 app 付款或在浏览器中输入支付宝账号和密码来完成支付。

手机网站支付和电脑网站支付的流程一致，接口的回调处理逻辑也是一致的。

> 支付请求：`com.alipay.api.request.AlipayTradeWapPayRequest`
>
> 业务参数：`com.alipay.api.domain.AlipayTradeWapPayModel`

#### 3.2.1 请求参数

| 参数         | 是否必选 | 描述                                                         |
| ------------ | -------- | ------------------------------------------------------------ |
| out_trade_no | 必选     | 商户网站唯一订单号                                           |
| total_amount | 必选     | 订单总金额。单位为元，精确到小数点后两位，取值范围：[0.01,100000000] |
| subject      | 必选     | 订单标题。注意：不可使用特殊字符，如 /，=，& 等。            |
| quit_url     | 可选     | 用户付款中途退出返回商户网站的地址                           |

构造出手机网站支付的请求参数为：

```java
@Data
public class MobilePayParam {

    private String outTradeNo;

    private String subject;

    private String totalAmount;
    
    private String quitUrl;

}
```

#### 3.2 1 支付逻辑

手机网站支付的支付逻辑如下：

```java
@Service
@Slf4j
public class AlipayServiceImpl implements AlipayService {

    @Resource
    private AlipayClient alipayClient;
    ......
    @Override
    public String mobilePay(MobilePayParam payParam) {
        // 创建请求对象
        AlipayTradeWapPayRequest request = new AlipayTradeWapPayRequest();
        // 设置回调地址
        request.setNotifyUrl(AlipayConstant.notifyUrl);
        request.setReturnUrl(AlipayConstant.returnUrl);
        // 创建业务对象
        AlipayTradeWapPayModel model = new AlipayTradeWapPayModel();
        // 设置业务参数
        model.setOutTradeNo(payParam.getOutTradeNo());
        model.setSubject(payParam.getSubject());
        model.setTotalAmount(payParam.getTotalAmount());
        model.setProductCode(AlipayConstant.mobilePayProductCode);
        if (StringUtils.hasLength(payParam.getQuitUrl())) {
            model.setQuitUrl(payParam.getQuitUrl());
        }
        request.setBizModel(model);
        AlipayTradeWapPayResponse response;
        try {
            // 发送请求
            response = alipayClient.pageExecute(request);
        } catch (AlipayApiException e) {
            e.printStackTrace();
            throw new RuntimeException("支付宝返回支付表单失败");
        }
        boolean isSuccess = response.isSuccess();
        return isSuccess ? response.getBody() : null;
    }
    ......
}
```

### 3.3 当面付（*买家扫描商户二维码*）

首先商家后台调用支付宝扫码支付接口，返回给商家后台一个支付二维码地址，商家后台需要将其转换成二维码，提供给买家。

和电脑网站支付类似，调用的都是交易创建类型的接口，支付的结果的返回时间依赖于用户何时扫码，所以此种支付方式也需要接口回调。

> 请求对象：`com.alipay.api.request.AlipayTradePrecreateRequest`
>
> 业务对象：`com.alipay.api.domain.AlipayTradePrecreateModel`

#### 3.3.1 请求参数

| 参数         | 是否必选 | 描述                                                         |
| ------------ | -------- | ------------------------------------------------------------ |
| out_trade_no | 必选     | 商户订单号。                                                 |
| total_amount | 必选     | 订单总金额。单位为元，精确到小数点后两位，取值范围：[0.01,100000000] |
| subject      | 必选     | 订单标题。注意：不可使用特殊字符，如 /，=，& 等。            |
| product_code | 可选     | 产品码。当面付默认为 FACE_TO_FACE_PAYMENT，如果签约的是当面付快捷版，则传 OFFLINE_PAYMENT |

构造出当面付的请求参数实体为：

```java
@Data
public class FTFPayParam {

    private String outTradeNo;

    private String totalAmount;

    private String subject;
    
}
```

#### 3.3.2 支付逻辑

这里将支付地址转换为二维码的工具是 Zxing，这里不介绍。当面付支付的逻辑代码如下：

```java
public class AlipayServiceImpl implements AlipayService {

    @Resource
    private AlipayClient alipayClient;
	......
    @Override
    public String faceToFacePay(FTFPayParam payParam) {
        AlipayTradePrecreateRequest request = new AlipayTradePrecreateRequest();
        request.setNotifyUrl(AlipayConstant.notifyUrl);
        request.setReturnUrl(AlipayConstant.returnUrl);
        AlipayTradePrecreateModel model = new AlipayTradePrecreateModel();
        model.setOutTradeNo(payParam.getOutTradeNo());
        model.setSubject(payParam.getSubject());
        model.setTotalAmount(payParam.getTotalAmount());
        model.setProductCode(AlipayConstant.faceToFaceProductCode);
        request.setBizModel(model);
        String qrCode = null;
        AlipayTradePrecreateResponse response = null;
        try {
            response = alipayClient.certificateExecute(request);
        } catch (AlipayApiException e) {
            e.printStackTrace();
            throw new RuntimeException("返回当面付二维码异常");
        }
        if (response.isSuccess()) {
            // 转换为 base64 格式的二维码图片
            qrCode = QRCodeHelper.toBase64(response.getQrCode());
        }
            
        return qrCode;
    }
	......
}
```

### 3.4 支付结果查询

前面的几种支付功能都是通过支付宝回调来确定支付状态的，但如果商户端出现了异常，如网络异常、服务器异常等，可能会导致商户系统接收不到支付通知，更不用说对订单的支付状态进行变更了。

支付宝提供了所有支付订单的查询接口，商户可根据这个接口主动查询支付结果，进而修改订单支付状态。

#### 3.4.1 请求参数

| 参数          | 是否必选 | 描述                                                    |
| ------------- | -------- | ------------------------------------------------------- |
| out_trade_no  | 特殊可选 | 订单支付时传入的商户订单号,和支付宝交易号不能同时为空。 |
| trade_no      | 特殊可选 | 支付宝交易号                                            |
| query_options | 可选     | 查询选项                                                |

`trade_no` 和 `out_trade_no` 如果同时存在优先取 `trade_no`；

查询选项 `query_options` 为数组类型，用于定制支付结果查询接口同步返回的字段，其可选值有：

1. trade_settle_info：返回的交易结算信息，包含分账、补差等信息；
2. fund_bill_list：交易支付使用的资金渠道；
3. voucher_detail_list：交易支付时使用的所有优惠券信息；
4. discount_goods_detail：交易支付所使用的单品券优惠的商品优惠信息；
5. mdiscount_amount：商家优惠金额；

#### 3.4.2 业务逻辑

支付结果查询逻辑代码如下：

```java
@Service
@Slf4j
public class AlipayServiceImpl implements AlipayService {

    @Resource
    private AlipayClient alipayClient;
	......
    @Override
    public Result queryPay(PayQueryParam payQueryParam) {
        // 创建支付结果查询请求对象
        AlipayTradeQueryRequest request = new AlipayTradeQueryRequest();
        // 创建支付结果查询业务对象
        AlipayTradeQueryModel model = new AlipayTradeQueryModel();
        if (StringUtils.hasLength(payQueryParam.getOutTradeNo())) {
            model.setOutTradeNo(payQueryParam.getOutTradeNo());
        }
        if (StringUtils.hasLength(payQueryParam.getTradeNo())) {
            model.setTradeNo(payQueryParam.getTradeNo());
        }
        model.setQueryOptions(payQueryParam.getQueryOptions());
        // 设置业务参数
        request.setBizModel(model);
        // 发送支付查询请求
        AlipayTradeQueryResponse response = null;
        try {
            response = alipayClient.certificateExecute(request);
        } catch (AlipayApiException e) {
            e.printStackTrace();
            throw new RuntimeException("支付结果查询异常");
        }
        // 获取支付状态
        String trade_status = response.getTradeStatus();
        if(response.isSuccess()) {
            if("WAIT_BUYER_PAY".equals(trade_status)) { // 交易创建等待买家付款
                return Result.success("等待买家付款",null);
            } else if ("TRADE_CLOSED".equals(trade_status)) { //交易超时，或支付完成后全额退款
                return Result.success("交易超时或支付完成后全额退款",null);
            } else if ("TRADE_SUCCESS".equals(trade_status)|| "TRADE_FINISHED".equals(trade_status)) { // 支付成功
                return Result.success("支付成功",null);
            }
        }
        return Result.fail("支付结果查询失败");
    }
    ......
}
```

支付结果查询的接口如下：

```java
@RestController
@RequestMapping("alipay")
public class AlipayController {

    @Resource
    private AlipayService alipayService;
    ......
    @PostMapping("payQuery")
    public Result payQuery(@RequestBody PayQueryParam payQuery) {
        return alipayService.queryPay(payQuery);
    }
    ......
}
```

## 四、退款接入

退款的流程和支付的流程都是类似的。需要注意的是，支付宝退款除了支持全额退款外还支持单笔交易分多次退款。

接入退款功能时，我们应该考虑*如何判断退款是否成功？*支付宝官方文档给出的答案很明确：

先通过退款请求的同步响应的 `fund_change` 参数，来判断退款是否成功，`fund_change=Y` 为退款成功，`fund_change=N` 或无此字段时需要通过退款查询接口来进一步确定退款状态。其中`fund_change=N` 不代表交易没有退款，只是代表该次接口请求没有资金变动，此时需使用退款查询接口进行查询判断，该笔交易是退款失败，还是退款成功后重复操作导致。

### 4.1 退款

如果要实现单笔交易多次退款需要保证订单号不变且需要设置不同的退款交易号。当一笔退款失败后，再次发起退款需要保证退款请求号不能变更。

全额退款时，支付宝是不会进行异步调用的；而部分退款，则一定会触发异步通知。所以在接入退款功能时并不建议以异步回调的结果作为退款是否成功的依据。

#### 4.1.1 请求参数

| 参数           | 是否必选 | 描述                                                         |
| -------------- | -------- | ------------------------------------------------------------ |
| out_trade_no   | 特殊可选 | 商户订单号。                                                 |
| trade_no       | 特殊可选 | 支付宝交易号。                                               |
| refund_amount  | 必选     | 退款金额。需要退款的金额，该金额不能大于订单金额             |
| refund_reason  | 可选     | 退款原因说明。                                               |
| out_request_no | 可选     | 退款请求号。标识一次退款请求，如需部分退款，则此参数必传。   |
| query_options  | 可选     | 查询选项。商户通过上送该参数来定制同步需要额外返回的字段，数组格式。 |

商户订单号 `out_trade_no` 和支付宝交易号 `trade_no` 不能同时为空；查询选项`query_options` 的可选值为：`refund_detail_item_list`：退款使用的资金渠道；`deposit_back_info`：触发银行卡冲退信息通知；

由此构造的退款参数实体为：

```java
@Data
public class RefundParam {

    // 订单号
    private String outTradeNo;

    // 支付宝交易号
    private String tradeNo;

    // 退款金额
    private String refundAmount;

    // 退款原因，可选参数
    private String refundReason;

    // 退款请求号，可选参数
    private String outRequestNo;

    // 查询选项，可选参数
    private List<String> queryOptions;

}
```

#### 4.1.2 响应参数

| 参数           | 是否固定 | 描述                                               |
| -------------- | -------- | -------------------------------------------------- |
| trade_no       | 固定     | 支付宝交易号                                       |
| out_trade_no   | 固定     | 商户订单号                                         |
| buyer_logon_id | 固定     | 用户的登录id                                       |
| fund_change    | 固定     | 本次退款是否发生了资金变化，Y：发生变化，N：未变化 |
| refund_fee     | 固定     | 退款总金额。指该笔交易累计已经退款成功的金额。     |

#### 4.1.3 退款逻辑

> 请求对象：`com.alipay.api.request.AlipayTradeRefundRequest`
>
> 业务对象：`com.alipay.api.domain.AlipayTradeRefundModel`

退款的逻辑如下：

```java
@Service
public class AliRefundServiceImpl implements AliRefundService {

    @Resource
    private AlipayClient alipayClient;
    .....
    @Override
    public Result refund(RefundParam refundParam) {
        // 创建退款请求
        AlipayTradeRefundRequest request = new AlipayTradeRefundRequest();
        // 创建请求参数对象
        AlipayTradeRefundModel model = new AlipayTradeRefundModel();
        if (!StringUtils.isEmpty(refundParam.getOutRequestNo())) {
            model.setOutTradeNo(refundParam.getOutTradeNo());
        }
        if ( !StringUtils.isEmpty(refundParam.getTradeNo())) {
            model.setTradeNo(refundParam.getTradeNo());
        }
        model.setRefundAmount(refundParam.getRefundAmount());
        model.setRefundReason(refundParam.getRefundReason());
        // 设置请求参数
        request.setBizModel(model);
        AlipayTradeRefundResponse response;
        try {
            // 发送退款请求
            response = alipayClient.certificateExecute(request);
        } catch (AlipayApiException e) {
            e.printStackTrace();
            throw new RuntimeException("退款失败");
        }
        // 退款结果
        String fundChange = response.getFundChange();
        if (response.isSuccess()) {
            if (Objects.equals(fundChange, "Y")) { // 退款成功
                return Result.success("退款成功",null);
            } else { // 退款调用资金未变动，查询退款结果
                // 构造退款查询参数
                RefundQueryParam refundQueryParam = new RefundQueryParam();
                BeanUtils.copyProperties(refundParam,refundQueryParam);
                // 调用退款查询接口，进一步判断退款状态
                return queryRefund(refundQueryParam);
            }
        }
        return Result.fail("退款失败");
    }
    ......
}
```

### 4.2 退款结果查询

退款查询接口返回 code=10000 并不代表退款成功，仅仅代表本次退款结果查询接口请求成功。如果退款查询接口的 `trade_no`、`out_trade_no`、`out_request_no` 和退款接口的不一致，则退款查询接口不会返回具体的退款信息，退款结果查询接口可在返回 code=10000 的前提下根据具体的退款信息判断退款是否成功。

#### 4.2.1 请求参数

| 参数           | 是否必选 | 描述                                                         |
| -------------- | -------- | ------------------------------------------------------------ |
| trade_no       | 特殊可选 | 支付宝交易号                                                 |
| out_trade_no   | 特殊可选 | 商户订单号                                                   |
| out_request_no | 必选     | 退款请求号，如果在退款请求时未传入，则该值为创建交易时的商户订单号 |
| query_options  | 可选     | 查询选项                                                     |

支付宝交易号 `trade_no` 和商户订单号 `out_trade_no` 不能同时为空。

查询选项 `query_options` 用于定制同步需要额外返回的信息字段，数组格式，可选值如下：

1. refund_detail_item_list：本次退款使用的资金渠道；

2. gmt_refund_pay：退款执行成功的时间；

3. deposit_back_info：银行卡冲退信息；

由此构造出的请求参数实体为：

```java
@Data
public class RefundQueryParam {

    // 支付宝交易号
    private String tradeNo;

    // 订单号
    private String outTradeNo;

    // 退款请求号
    private String outRequestNo;

    // 查询选项，可选参数
    private List<String> queryOptions;
}
```



#### 4.2.2 业务逻辑

> 请求对象：`com.alipay.api.request.AlipayTradeFastpayRefundQueryRequest`
>
> 业务对象：`com.alipay.api.domain.AlipayTradeFastpayRefundQueryModel`

退款结果查询的实现逻辑如下：

```java
@Service
public class AliRefundServiceImpl implements AliRefundService {
    
    @Override
    public Result queryRefund(RefundQueryParam refundQueryParam) {
        // 创建请求
        AlipayTradeFastpayRefundQueryRequest request = 
            new AlipayTradeFastpayRefundQueryRequest();
        // 创建请求参数对象
        AlipayTradeFastpayRefundQueryModel model = 
            new AlipayTradeFastpayRefundQueryModel();
        if (StringUtils.hasLength(refundQueryParam.getOutTradeNo())) {
            model.setOutTradeNo(refundQueryParam.getOutTradeNo());
        }
        if (StringUtils.hasLength(refundQueryParam.getTradeNo())) {
            model.setTradeNo(refundQueryParam.getTradeNo());
        }
        model.setOutRequestNo(refundQueryParam.getOutRequestNo());
        model.setQueryOptions(refundQueryParam.getQueryOptions());
        // 设置请求参数
        request.setBizModel(model);
        AlipayTradeFastpayRefundQueryResponse response = null;
        try {
            // 发起请求
            response = alipayClient.certificateExecute(request);
        } catch (AlipayApiException e) {
            e.printStackTrace();
            throw new RuntimeException("退款失败");
        }
        // 获取请求状态
        String refund_status = response.getRefundStatus();
        if (response.isSuccess()) {
            if ("REFUND_SUCCESS".equals(refund_status)) { // 退款成功
                return Result.success("退款成功", null);
            } else { // 退款请求未收到或退款失败
                if (StringUtils.hasLength(refund_status)) {
                    return Result.fail("退款失败");
                } else {
                    return Result.fail("该退款订单不存在");
                }
            }
        } else {
            return Result.fail("获取退款结果失败");
        }
    }
}
```

## 五、转账接入

以下两段内容来自支付宝官方文档：

> 产品介绍：
>
> 支付包提供了转账到支付宝的接口，针对具备开发能力的商家，提供通过 API 接口完成单笔转账的功能。商家只需输入另一个正确的支付宝账号，即可将资金从本企业支付宝账户转账至另一个支付宝账户。  该产品适用行业较广，可用于商家间的货款结算、转账汇款，商家给企业或个人发放佣金等。

>使用限制：
>
>目前仅支持账户余额渠道付款，且收款用户的支付宝账号需要完成实名认证，部分用户可能因为账户状态无法收款。单笔转账到支付宝账户为**实时到账**且不支持服务商通过第三方应用代商家调用。

支付宝转账可分为转账到支付宝账户和转账到银行卡。接入这两种转账方式前，先来了解两个转账的辅助接口：**查询支付宝账户资金** 和 **查询转账业务单据**。下面给出的转账流程也涉及到这两个接口

下面是转账调用流程：

1. 查询当前商户账户的可用余额，同步返回这个可用余额。
2. 若返回的可用余额不小于当前转账金额，则发起转账调用。
3. 获取转账调用的同步响应结果，确定转账状态。
4. 通过转账单据查询接口进一步确定转账状态。

### 5.1 查询支付宝账户资金

在执行转账操作之前，需要确保当前商户的账户余额不小于转账金额。

#### 5.1.1 请求参数

| 参数           | 是否必选 | 描述                                                         |
| -------------- | -------- | ------------------------------------------------------------ |
| alipay_user_id | 必选     | 支付宝会员 id                                                |
| account_type   | 特殊可选 | 查询的账号类型和查询余额账户值为 ACCTRANS_ACCOUNT，为必填参数 |

由于这两个参数在系统中一般固定不变，所以将其定义为常量。

#### 5.1.2 响应参数

| 参数             | 固定返回 | 描述                                       |
| ---------------- | -------- | ------------------------------------------ |
| available_amount | 固定     | 账户可用余额，单位元，精确到小数点后两位。 |
| freeze_amount    | 不固定   | 当前支付宝账户的实时冻结余额               |

#### 5.1.2 业务逻辑

> 请求对象：`com.alipay.api.request.AlipayFundAccountQueryRequest`
>
> 业务对象：`com.alipay.api.domain.AlipayFundAccountQueryModel`

查询支付宝账户资金的处理逻辑如下：

```java
@Service
public class AliTransferServiceImpl implements AliTransferService {

    @Resource
    private AlipayClient alipayClient;
    ......
    @Override
    public Map<String, String> queryAccount() {
        // 创建查询请求
        AlipayFundAccountQueryRequest request = new AlipayFundAccountQueryRequest();
        // 创建业务对象
        AlipayFundAccountQueryModel model = new AlipayFundAccountQueryModel();
        // 设置业务参数
        model.setAlipayUserId(AlipayConstant.pid);
        model.setAccountType(AlipayConstant.accountType);
        request.setBizModel(model);
        AlipayFundAccountQueryResponse response;
        try {
            // 发送请求
            response = alipayClient.certificateExecute(request);
        } catch (AlipayApiException e) {
            e.printStackTrace();
            throw new RuntimeException("获取商户账户信息失败");
        }
        Map<String,String> result = new HashMap<>();
        if(response.isSuccess()) {
            // 获取可用余额
            String availableAmount = response.getAvailableAmount();
            // 获取冻结资金
            String freezeAmount = response.getFreezeAmount();
            result.put("status", "success");
            result.put("availableAmount", availableAmount);
            result.put("freezeAmount", freezeAmount);
        } else {
            result.put("status", "fail");
        }
        return result;
    }
    ......
}
```

### 5.2 查询转账业务单据

#### 5.2.1 请求参数

查询转账业务单据的参数支付宝转账单据号 `order_id` 、支付宝支付流水号 `pay_fund_order_id` 以及商户转账订单号 `out_biz_no` 三者不能同时为空，至于它们同时存在或两两存在如何取值可参考支付宝官方文档，这里仅仅列出了使用 `out_biz_no` 时的必传参数。

| 参数         | 是否必选 | 描述                                                         |
| ------------ | :------- | :----------------------------------------------------------- |
| product_code | 必选     | 销售产品码，如果使用out_biz_no则该字段必传。可传值如下：<br/>TRANS_ACCOUNT_NO_PWD：单笔无密转账到支付宝账户<br/>TRANS_BANKCARD_NO_PWD：单笔无密转账到银行卡 |
| biz_scene    | 必选     | 业务场景，如果传递了out_biz_no则该字段必传。单笔无密转账固定为DIRECT_TRANSFER |
| out_biz_no   | 必选     | 转账订单号                                                   |

这里仅仅处理单笔无密转账的业务场景，可将 `biz_scene` 定义为常量，将其它请求参数定位 Bean，代码如下：

```java
@Data
public class TransferQueryParam {

    private String outBizNo;

    private String productCode;
}
```

#### 5.2.2 响应参数

这里仅仅介绍了包括确定转账状态在内的部分响应参数，更多的响应参数说明可参考支付宝官方文档。

| 参数              | 是否固定 | 描述                                                         |
| ----------------- | -------- | ------------------------------------------------------------ |
| order_id          | 不固定   | 查询失败不返回                                               |
| pay_fund_order_id | 不固定   | 转账失败不返回                                               |
| out_biz_no        | 固定     | 商户订单号                                                   |
| trans_amount      | 不固定   | 付款成功后的支付金额，订单状态为SUCCESS才返回，其他状态不返回 |
| status            | 固定     | 转账单据状态，涉及 alipay.fund.trans.uni.transfer 接口的状态为：<br/>SUCCESS：转账成功<br/>FAIL：单笔转账到银行卡失败<br/>DEALING：单笔转账到银行卡处理中<br/>REFUND：单笔转账到银行卡退票 |

#### 5.2.3 业务逻辑

> 请求对象：`com.alipay.api.request.AlipayFundTransCommonQueryRequest`
>
> 业务对象：`com.alipay.api.domain.AlipayFundTransCommonQueryModel`

查询转账业务单据的处理逻辑代码如下：

```java
@Service
public class AliTransferServiceImpl implements AliTransferService {

    @Resource
    private AlipayClient alipayClient;
    ......
    @Override
    public Result queryTransfer(TransferQueryParam queryParam) {
        // 创建请求参数
        AlipayFundTransCommonQueryRequest request = 
            new AlipayFundTransCommonQueryRequest();
        // 创建业务对象
        AlipayFundTransCommonQueryModel model = new AlipayFundTransCommonQueryModel();
        // 设置业务参数
        model.setOutBizNo(queryParam.getOutBizNo());
        model.setProductCode(queryParam.getProductCode());
        request.setBizModel(model);
        AlipayFundTransCommonQueryResponse response = null;
        try {
            // 发送请求
            response = alipayClient.certificateExecute(request);
        } catch (AlipayApiException e) {
            e.printStackTrace();
            throw new RuntimeException("获取转账状态失败");
        }
        if (response.isSuccess()) {
            String status = response.getStatus();
            if("SUCCESS".equals(status)) {
                return Result.success("转账成功", null);
            } else if ("REFUND".equals(status)) {
                return Result.success("银行卡转账退票", null);
            } else if ("FAIL".equals(status)) {
                return Result.success("转账到银行卡失败", null);
            } else if ("DEALING".equals(status)) {
                return Result.success("处理中", null);
            }
        }
        return Result.fail("获取转账状态失败");
    }
    ......
}
```

### 5.3 转账

转账到支付宝账户和转账到银行卡的接口都是：`alipay.fund.trans.uni.transfer` ，此接口会同步返回转账状态。

#### 5.3.1 请求参数

| 参数         | 是否必选 | 描述                                                         |
| ------------ | -------- | ------------------------------------------------------------ |
| out_biz_no   | 必选     | 商家侧定义的订单号，需要保证唯一                             |
| trans_amount | 必选     | 转账金额，取值范围[0.1,100000000]                            |
| product_code | 必选     | 销售产品码。可选值为：<br/>单笔无密转账固定为：TRANS_ACCOUNT_NO_PWD<br/>单笔无密转账到银行卡固定为：TRANS_BANKCARD_NO_PWD |
| payee_info   | 必选     | 收款方信息                                                   |
| biz_scene    | 可选     | 业务场景。单笔无密转账固定为 DIRECT_TRANSFER                 |
| order_title  | 可选     | 转账业务的标题，用于在支付宝用户的账单里显示                 |
| remark       | 可选     | 业务备注                                                     |

收款方信息是一个对象，其属性为：

| 参数          | 是否必选 | 描述                                                         |
| ------------- | -------- | ------------------------------------------------------------ |
| identity      | 必选     | 收款账号，分为如下几种情况：<br/>转账到银行卡，该值为银行卡号<br/>当identity_type=ALIPAY_USER_ID 时，该值为支付宝用户UID<br/>当identity_type=ALIPAY_LOGON_ID 时，该值填写支付宝登录号。 |
| identity_type | 必选     | 转账账号类型，分为如下几种情况：<br/>单笔无密转账到银行卡固定为：BANKCARD_ACCOUNT<br/>单笔无密转账到支付宝用户 UID 固定为：ALIPAY_USER_ID<br/>单笔无密转账到支付宝登录号固定为：ALIPAY_LOGON_ID |
| name          | 可选     | 当 identity_type=ALIPAY_LOGON_ID 时，本字段必填。            |

其中的业务场景 `biz_scene` 和查询支付包账户资金以及查询转账业务单据均固定为：`DIRECT_TRANSFER`，其余的参数可将其定义为 Bean 代码如下：

```java
@Data
public class TransferParam {

    // 订单号
    private String outBizNo;

    // 转账金额
    private String transAmount;

    // 产品码
    private String productCode;

    // 订单标题
    private String orderTitle;

    // 账号
    private String identity;

    // 账号类型
    private String identityType;
    
    // 收款用户名
    private String name;

    // 转账备注 可选参数
    private String remark;

}
```

#### 5.3.2 响应参数

| 参数              | 是否固定 | 描述                                                         |
| ----------------- | -------- | ------------------------------------------------------------ |
| out_biz_no        | 固定     | 商户订单号                                                   |
| order_id          | 固定     | 支付宝转账订单号                                             |
| pay_fund_order_id | 不固定   | 支付宝支付资金流水号                                         |
| status            | 固定     | 转账单据状态，可选值为：<br/>SUCCESS：转账成功<br/>REFUND：转账银行卡退票<br/>FAIL：失败<br/>DEALING：转账到银行卡处理中 |

#### 5.3.3 业务逻辑

> 请求对象：`com.alipay.api.request.AlipayFundAccountQueryRequest`
>
> 业务对象：`com.alipay.api.domain.AlipayFundAccountQueryModel`

转账的业务逻辑代码如下：

```java
@Service
public class AliTransferServiceImpl implements AliTransferService {
    @Resource
    private AlipayClient alipayClient;
    ......
    @Override
    public Result transfer(TransferParam transferParam) {
        // 查询商户账户余额
        Map<String, String> accountMap = queryAccount();
        // 获取查询状态
        String status = accountMap.get("status");
        if ("fail".equals(status)) {
            return Result.fail("查询商户账户余额失败");
        }
        // 获取商户余额
        String availableAmount = accountMap.get("availableAmount");
        // 比较商户余额和转账资金
        double v = Double.parseDouble(availableAmount);
        double v1 = Double.parseDouble(transferParam.getTransAmount());
        if (v < v1) {
            return Result.fail("商户账号余额不足，无法转账");
        }
        // 创建转账请求
        AlipayFundTransUniTransferRequest request = 
            new AlipayFundTransUniTransferRequest();
        // 创建转账业务对象
        AlipayFundTransUniTransferModel model = new AlipayFundTransUniTransferModel();
        // 设置转账业务参数
        model.setOutBizNo(transferParam.getOutBizNo());
        model.setTransAmount(transferParam.getTransAmount());
        model.setOrderTitle(transferParam.getOrderTitle());
        model.setRemark(transferParam.getRemark());
        model.setProductCode(transferParam.getProductCode());
        model.setBizScene(AlipayConstant.singleTransferBizScene);
        // 设置收款人信息
        Participant payeeInfo = new Participant();
        payeeInfo.setIdentity(transferParam.getIdentity());
        payeeInfo.setIdentityType(transferParam.getIdentityType());
        if (StringUtils.hasLength(transferParam.getName())) {
            payeeInfo.setName(transferParam.getName());
        }
        model.setPayeeInfo(payeeInfo);
        if (StringUtils.hasLength(transferParam.getName())) {
            payeeInfo.setName(transferParam.getName());
        }
        request.setBizModel(model);
        AlipayFundTransUniTransferResponse response = null;
        try {
            // 发送请求
            response = alipayClient.certificateExecute(request);
        } catch (AlipayApiException e) {
            e.printStackTrace();
            throw new RuntimeException("转账异常");
        }
        if (response.isSuccess()) {
            String responseStatus = response.getStatus();
            if ("SUCCESS".equals(responseStatus)) { // 转账成功
                return Result.success("转账成功", null);
            } else { // 业务单据查询接口，进一步确定转账状态
                TransferQueryParam queryParam = new TransferQueryParam();
                BeanUtils.copyProperties(transferParam, queryParam);
                return queryTransfer(queryParam);
            }
        }
        return Result.fail("转账失败");
    }
    ......
}
```

## 六、下载对账单

为方便商户快速查账，支付宝提供了对账单下载地址接口。

### 6.1 请求参数

| 参数      | 是否必选 | 描述                                                         |
| --------- | -------- | ------------------------------------------------------------ |
| bill_type | 必选     | 账单类型                                                     |
| bill_date | 必选     | 账单时间：日账单格式为 yyyy-MM-dd，月账单格式为 yyyy-MM      |
| smid      | 可选     | 二级商户smid，这个参数只在 bill_type 是 trade_zft_merchant 时才能使用 |

商户通过接口或开放平台授权后可获取账单类型 `bill_type` 的可选值为：

`trade`：商户基于支付宝交易收单的业务账单；

`signcustomer`：基于商户支付宝余额收入及支出等资金变动的账务账单；

`merchant_act`：营销活动账单，包含营销活动的发放，核销记录；

`trade_zft_merchant`：直付通二级商户查询交易的业务账单；

`zft_acc`：直付通平台商查询二级商户流水使用，返回所有二级商户流水；

由此构造的请求参数实体为：

```java
@Data
public class BillQueryParam {

    // 账单类型
    private String billType;

    // 账单时间
    private String billDate;

    // 二级商户smid
    private String smid;

}
```

### 6.2 业务逻辑

> 请求对象：`com.alipay.api.request.AlipayDataDataserviceBillDownloadurlQueryRequest`
>
> 业务对象：`com.alipay.api.domain.AlipayDataDataserviceBillDownloadurlQueryModel`

查询对账单下载地址的业务逻辑代码如下：

```java
@Service
@Slf4j
public class AlipayServiceImpl implements AlipayService {
    
    @Resource
    private AlipayClient alipayClient;
    
    @Override
    public String queryBill(BillQueryParam queryParam) {
        // 创建请求对象
        AlipayDataDataserviceBillDownloadurlQueryRequest request =
                new AlipayDataDataserviceBillDownloadurlQueryRequest();
        // 创建业务对象
        AlipayDataDataserviceBillDownloadurlQueryModel model =
                new AlipayDataDataserviceBillDownloadurlQueryModel();
        // 设置业务参数
        model.setBillType(queryParam.getBillType());
        model.setBillDate(queryParam.getBillDate());
        if (StringUtils.hasLength(queryParam.getSmid())) {
            model.setSmid(queryParam.getSmid());
        }
        request.setBizModel(model);
        String downloadUrl = null;
        AlipayDataDataserviceBillDownloadurlQueryResponse response;
        try {
            // 发送请求
            response = alipayClient.certificateExecute(request);
        } catch (AlipayApiException e) {
            e.printStackTrace();
            throw new RuntimeException("获取对账单下载地址异常");
        }
        if (response.isSuccess()) {
            // 获取对账单下载地址
            downloadUrl = response.getBillDownloadUrl();
        }
        return downloadUrl;
    }
}
```

